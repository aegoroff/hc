/*!
 * \brief   The file contains Hash LINQ implementation
 * \author  \verbatim
            Created by: Alexander Egorov
            \endverbatim
 * \date    \verbatim
            Creation date: 2011-11-14
            \endverbatim
 * Copyright: (c) Alexander Egorov 2009-2013
 */

#include "targetver.h"
#include "argtable2.h"
#include "hlinq.h"

#ifdef WIN32
#include "..\srclib\DebugHelplers.h"
#endif

#define ERROR_BUFFER_SIZE 2 * BINARY_THOUSAND
#define LINE_FEED '\n'

#define HLP_OPT_BEGIN "  -%c [ --%s ] "
#define HLP_OPT_END "\t\t%s" NEW_LINE NEW_LINE
#define HLP_ARG HLP_OPT_BEGIN "arg" HLP_OPT_END
#define HLP_NO_ARG HLP_OPT_BEGIN HLP_OPT_END

#define PATH_ELT_SEPARATOR '\\'
#define NUMBER_PARAM_FMT_STRING "%lu"
#define BIG_NUMBER_PARAM_FMT_STRING "%llu"

#define INVALID_DIGIT_PARAMETER "Invalid parameter --%s %s. Must be number" NEW_LINE
#define INCOMPATIBLE_OPTIONS_HEAD "Incompatible options: "

#define OPT_HELP '?'
#define OPT_FILE 'f'
#define OPT_QUERY 'c'
#define OPT_VALIDATE 's'
#define OPT_TIME 't'
#define OPT_LOWER 'l'
#define OPT_PARAM 'p'

#define MAX_LINE_SIZE 32 * BINARY_THOUSAND - 1

int main(int argc, const char* const argv[])
{
    apr_pool_t* pool = NULL;
    apr_getopt_t* opt = NULL;
    int c = 0;
    const char* optarg = NULL;
    apr_status_t status = APR_SUCCESS;

    pANTLR3_INPUT_STREAM input;
    pHLINQLexer lxr;
    pANTLR3_COMMON_TOKEN_STREAM tstream;
    pHLINQParser psr;
    pANTLR3_COMMON_TREE_NODE_STREAM nodes;
    pHLINQWalker treePsr;

    HLINQParser_prog_return ast;
    int nerrors;
    void* argtable[8];

    struct arg_str  *command       = arg_strn("c", "command", NULL, 0, 1, "query text from command line");
    struct arg_file *validate      = arg_filen("p", "param", NULL, 0, 1, "path to file that will be validated using query");
    struct arg_lit  *help          = arg_lit0("h", "help", "print this help and exit");
    struct arg_lit  *syntaxonly    = arg_lit0("s", "syntaxonly", "only validate syntax. Do not run actions");
    struct arg_lit  *time          = arg_lit0("t", "time", "show calculation time (false by default)");
    struct arg_lit  *lower         = arg_lit0("l", "lower", "output hash using low case (false by default)");
    struct arg_file *files         = arg_filen(NULL, NULL, NULL, 0, argc+2, "one or more query files");
    struct arg_end  *end           = arg_end(1);

    argtable[0] = command;
    argtable[1] = validate;
    argtable[2] = syntaxonly;
    argtable[3] = time;
    argtable[4] = lower;
    argtable[5] = help;
    argtable[6] = files;
    argtable[7] = end;

#ifdef WIN32
#ifndef _DEBUG  // only Release configuration dump generating
    SetUnhandledExceptionFilter(TopLevelFilter);
#endif
#endif

    setlocale(LC_ALL, ".ACP");
    setlocale(LC_NUMERIC, "C");

    status = apr_app_initialize(&argc, &argv, NULL);
    if (status != APR_SUCCESS) {
        CrtPrintf("Couldn't initialize APR");
        NewLine();
        PrintError(status);
        return EXIT_FAILURE;
    }
    atexit(apr_terminate);
    apr_pool_create(&pool, NULL);

    if (arg_nullcheck(argtable) != 0) {
        PrintCopyright();
        arg_print_syntax(stdout, argtable, "\n");
        goto cleanup;
    }

    /* Parse the command line as defined by argtable[] */
    nerrors = arg_parse(argc, argv, argtable);

    if (help->count > 0) {
        PrintCopyright();
        arg_print_syntax(stdout, argtable, "\n");
        goto cleanup;
    }
    if (nerrors > 0 || argc < 2) {
        PrintCopyright();
        arg_print_errors(stdout, end, PROGRAM_NAME);
        arg_print_syntax(stdout, argtable, "\n");
        goto cleanup;
    }

    if ((files->count == NULL) && (command->count == NULL)) {
        PrintCopyright();
        CrtPrintf("file or query must be specified" NEW_LINE);
        goto cleanup;
    }

    input   = command->count == NULL
              ? antlr3FileStreamNew((pANTLR3_UINT8)files->filename[0], ANTLR3_ENC_UTF8)
              : antlr3StringStreamNew((pANTLR3_UINT8)command->sval[0], ANTLR3_ENC_UTF8,
                                      (ANTLR3_UINT32)strlen(command->sval[0]), (pANTLR3_UINT8)"");

    if (input == NULL) {
        PrintCopyright();
        CrtPrintf("Unable to open file %s" NEW_LINE, files->filename[0]);
        goto cleanup;
    }

    lxr     = HLINQLexerNew(input);     // HLINQLexerNew is generated by ANTLR
    tstream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));
    psr     = HLINQParserNew(tstream);  // HLINQParserNew is generated by ANTLR3
    ast = psr->prog(psr);

    if (psr->pParser->rec->state->errorCount > 0) {
        CrtPrintf("%d syntax error(s) found. Query aborted." NEW_LINE,
                  psr->pParser->rec->state->errorCount);
    } else if (ast.tree != NULL) {
        nodes   = antlr3CommonTreeNodeStreamNewTree(ast.tree, ANTLR3_SIZE_HINT); // sIZE HINT WILL SOON BE DEPRECATED!!

        // Tree parsers are given a common tree node stream (or your override)
        //
        treePsr = HLINQWalkerNew(nodes);
        
        treePsr->prog(treePsr, pool, syntaxonly->count, time->count, lower->count, validate->filename[0]);
        nodes->free(nodes);
        nodes = NULL;
        treePsr->free(treePsr);
        treePsr = NULL;
    }

    psr->free(psr);
    psr = NULL;
    tstream->free(tstream);
    tstream = NULL;
    lxr->free(lxr);
    lxr = NULL;
    input->close(input);
    input = NULL;
cleanup:
    /* deallocate each non-null entry in argtable[] */
    arg_freetable(argtable, sizeof(argtable) / sizeof(argtable[0]));
    apr_pool_destroy(pool);
    return EXIT_SUCCESS;
}

void PrintUsage(void)
{
    //int i = 0;
    //PrintCopyright();
    //CrtPrintf("usage: " PROGRAM_NAME " [OPTION] ..." NEW_LINE NEW_LINE "Options:" NEW_LINE NEW_LINE);
    //for (; i < sizeof(options) / sizeof(apr_getopt_option_t); ++i) {
    //    CrtPrintf(options[i].has_arg ? HLP_ARG : HLP_NO_ARG,
    //              (char)options[i].optch, options[i].name, options[i].description);
    //}
}

void PrintCopyright(void)
{
    CrtPrintf(COPYRIGHT_FMT, APP_NAME);
}
