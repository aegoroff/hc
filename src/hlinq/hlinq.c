/*!
 * \brief   The file contains Hash LINQ implementation
 * \author  \verbatim
            Created by: Alexander Egorov
            \endverbatim
 * \date    \verbatim
            Creation date: 2011-11-14
            \endverbatim
 * Copyright: (c) Alexander Egorov 2009-2013
 */

#include "targetver.h"
#include "argtable2.h"
#include "hlinq.h"

#ifdef WIN32
#include "..\srclib\DebugHelplers.h"
#endif

#define ERROR_BUFFER_SIZE 2 * BINARY_THOUSAND
#define LINE_FEED '\n'

#define PATH_ELT_SEPARATOR '\\'
#define NUMBER_PARAM_FMT_STRING "%lu"
#define BIG_NUMBER_PARAM_FMT_STRING "%llu"

#define INVALID_DIGIT_PARAMETER "Invalid parameter --%s %s. Must be number" NEW_LINE
#define INCOMPATIBLE_OPTIONS_HEAD "Incompatible options: "

#define MAX_LINE_SIZE 32 * BINARY_THOUSAND - 1

int main(int argc, const char* const argv[])
{
    apr_pool_t* pool = NULL;
    apr_status_t status = APR_SUCCESS;
    pANTLR3_INPUT_STREAM input;
    int nerrors;

    struct arg_str  *command       = arg_strn("c", "command", NULL, 0, 1, "query text from command line");
    struct arg_file *validate      = arg_file0("p", "param", NULL, "path to file that will be validated using one or more queries");
    struct arg_lit  *help          = arg_lit0("h", "help", "print this help and exit");
    struct arg_lit  *syntaxonly    = arg_lit0("s", "syntaxonly", "only validate syntax. Do not run actions");
    struct arg_lit  *time          = arg_lit0("t", "time", "show calculation time (false by default)");
    struct arg_lit  *lower         = arg_lit0("l", "lower", "output hash using low case (false by default)");
    struct arg_file *files         = arg_filen(NULL, NULL, NULL, 0, argc+2, "one or more query files");
    struct arg_end  *end           = arg_end(1);

    void* argtable[] = { command, validate, syntaxonly, time, lower, help, files, end };

#ifdef WIN32
#ifndef _DEBUG  // only Release configuration dump generating
    SetUnhandledExceptionFilter(TopLevelFilter);
#endif
#endif

    setlocale(LC_ALL, ".ACP");
    setlocale(LC_NUMERIC, "C");

    status = apr_app_initialize(&argc, &argv, NULL);
    if (status != APR_SUCCESS) {
        CrtPrintf("Couldn't initialize APR");
        NewLine();
        PrintError(status);
        return EXIT_FAILURE;
    }
    atexit(apr_terminate);
    apr_pool_create(&pool, NULL);

    if (arg_nullcheck(argtable) != 0) {
        PrintSyntax(argtable);
        goto cleanup;
    }

    /* Parse the command line as defined by argtable[] */
    nerrors = arg_parse(argc, argv, argtable);

    if (help->count > 0) {
        PrintSyntax(argtable);
        goto cleanup;
    }
    if (nerrors > 0 || argc < 2) {
        arg_print_errors(stdout, end, PROGRAM_NAME);
        PrintSyntax(argtable);
        goto cleanup;
    }

    if ((files->count == NULL) && (command->count == NULL)) {
        PrintCopyright();
        CrtPrintf("file or query must be specified" NEW_LINE);
        goto cleanup;
    }

    if (command->count > 0) {
        input = antlr3StringStreamNew((pANTLR3_UINT8)command->sval[0], ANTLR3_ENC_UTF8,
                                      (ANTLR3_UINT32)strlen(command->sval[0]), (pANTLR3_UINT8)"");
        RunQuery(input, syntaxonly->count, time->count, lower->count, validate->filename[0], pool);
    } else {
        int i = 0;
        for (; i < files->count; i++) {
            input = antlr3FileStreamNew((pANTLR3_UINT8)files->filename[i], ANTLR3_ENC_UTF8);

            if (input == NULL) {
                CrtPrintf("Unable to open file %s" NEW_LINE, files->filename[i]);
                continue;
            }
            RunQuery(input, syntaxonly->count, time->count, lower->count, validate->filename[0], pool);
        }
    }

cleanup:
    /* deallocate each non-null entry in argtable[] */
    arg_freetable(argtable, sizeof(argtable) / sizeof(argtable[0]));
    apr_pool_destroy(pool);
    return EXIT_SUCCESS;
}

void PrintSyntax(void* argtable) {
    PrintCopyright();
    arg_print_syntax(stdout, argtable, NEW_LINE NEW_LINE);
    arg_print_glossary_gnu(stdout,argtable,"  %-25s %s" NEW_LINE);
}

void RunQuery(pANTLR3_INPUT_STREAM input, BOOL onlyValidate, BOOL isPrintCalcTime, BOOL isPrintLowCase, const char* param, apr_pool_t* pool)
{
    pHLINQLexer lxr;
    pANTLR3_COMMON_TOKEN_STREAM tstream;
    pHLINQParser psr;
    pANTLR3_COMMON_TREE_NODE_STREAM nodes;
    pHLINQWalker treePsr;

    HLINQParser_prog_return ast;

    lxr     = HLINQLexerNew(input);     // HLINQLexerNew is generated by ANTLR
    tstream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));
    psr     = HLINQParserNew(tstream);  // HLINQParserNew is generated by ANTLR3
    ast = psr->prog(psr);

    if (psr->pParser->rec->state->errorCount > 0) {
        CrtPrintf("%d syntax error(s) found. Query aborted." NEW_LINE,
                  psr->pParser->rec->state->errorCount);
    } else if (ast.tree != NULL) {
        nodes   = antlr3CommonTreeNodeStreamNewTree(ast.tree, ANTLR3_SIZE_HINT); // sIZE HINT WILL SOON BE DEPRECATED!!

        // Tree parsers are given a common tree node stream (or your override)
        //
        treePsr = HLINQWalkerNew(nodes);
        
        treePsr->prog(treePsr, pool, onlyValidate, isPrintCalcTime, isPrintLowCase, param);
        nodes->free(nodes);
        nodes = NULL;
        treePsr->free(treePsr);
        treePsr = NULL;
    }

    psr->free(psr);
    psr = NULL;
    tstream->free(tstream);
    tstream = NULL;
    lxr->free(lxr);
    lxr = NULL;
    input->close(input);
    input = NULL;
}

void PrintCopyright(void)
{
    CrtPrintf(COPYRIGHT_FMT, APP_NAME);
}
