/*!
 * \brief   The file contains class implementation
 * \author  \verbatim
            Created by: Alexander Egorov
            \endverbatim
 * \date    \verbatim
            Creation date: 2011-11-18
            \endverbatim
 * Copyright: (c) Alexander Egorov 2011
 */

#include <iostream>
#include <fstream>
#include <stdio.h>
#include "HLINQTest.h"
using namespace std;

#define TEST_QUERY_FILE "example.hq"

void HLINQTest::SetUp()
{
    cout_stream_buffer_ = cout.rdbuf(oss_.rdbuf());
}

void HLINQTest::TearDown()
{
    __try {
        cout.rdbuf(cout_stream_buffer_);
        if (nodes_ != NULL){
            nodes_->free(nodes_);
            nodes_ = NULL;
	        treePsr_ ->free  (treePsr_);
            treePsr_	= NULL;
        }
        psr_->free(psr_);
        psr_ = NULL;
        tstream_->free(tstream_);
        tstream_ = NULL;
        lxr_->free(lxr_);
        lxr_ = NULL;
        input_->close(input_);
        input_ = NULL;
    } __finally {
        if((_access(TEST_QUERY_FILE, 0)) != -1) {
            remove(TEST_QUERY_FILE);
        }
    }
}

void HLINQTest::Run(const char* q, BOOL dontRunActions)
{
    const char* utf8 = FromAnsiToUtf8(q, pool_);
    input_   = antlr3StringStreamNew((pANTLR3_UINT8)utf8, ANTLR3_ENC_UTF8, strlen(q), (pANTLR3_UINT8)"");
    lxr_     = HLINQLexerNew(input_);     // HLINQLexerNew is generated by ANTLR
    tstream_ = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr_));
    psr_     = HLINQParserNew(tstream_);  // HLINQParserNew is generated by ANTLR3
    ast_ = psr_->prog(psr_);
    nodes_ = NULL;
    if (ast_.tree == NULL) {
        return;
    }
    
    nodes_	= antlr3CommonTreeNodeStreamNewTree(ast_.tree, ANTLR3_SIZE_HINT); // sIZE HINT WILL SOON BE DEPRECATED!!
	treePsr_	= HLINQWalkerNew(nodes_);
    treePsr_->prog(treePsr_, pool_, dontRunActions, FALSE, FALSE);
}

void HLINQTest::RunFile(const char* file, BOOL dontRunActions)
{
    input_   = antlr3FileStreamNew((pANTLR3_UINT8)file, ANTLR3_ENC_UTF8);
    lxr_     = HLINQLexerNew(input_);     // HLINQLexerNew is generated by ANTLR
    tstream_ = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr_));
    psr_     = HLINQParserNew(tstream_);  // HLINQParserNew is generated by ANTLR3
    ast_ = psr_->prog(psr_);
    nodes_ = NULL;
    if (ast_.tree == NULL) {
        return;
    }
    
    nodes_	= antlr3CommonTreeNodeStreamNewTree(ast_.tree, ANTLR3_SIZE_HINT); // sIZE HINT WILL SOON BE DEPRECATED!!
	treePsr_	= HLINQWalkerNew(nodes_);
    treePsr_->prog(treePsr_, pool_, dontRunActions, FALSE, FALSE);
}

void HLINQTest::ValidateNoError()
{
    ASSERT_STREQ("", oss_.str().c_str());
}

void HLINQTest::ValidateError()
{
    ASSERT_TRUE(oss_.str().length() > 0);
}

TEST_F(HLINQTest, OnlyComment) {
    Run("# Comment\n");
    ValidateNoError();
}

TEST_F(HLINQTest, CommentUnixLine) {
    Run("# Comment\nfor file f from dir 'c:' where f.size == 0 do find;");
    ValidateNoError();
}

TEST_F(HLINQTest, CommentWinLine) {
    Run("# Comment\r\nfor file f from dir 'c:' where f.size == 0 do find;");
    ValidateNoError();
}

TEST_F(HLINQTest, FileNameEq) {
    Run("for file f from dir 'c:' where f.name == 'test' do find;");
    ValidateNoError();
}

TEST_F(HLINQTest, CalcStrHash) {
    Run("for string '123' do md5;", FALSE);
    ASSERT_STREQ("202CB962AC59075B964B07152D234B70\n", oss_.str().c_str());
}

TEST_F(HLINQTest, CrackStrHashMaxSet) {
    Run("for string s from hash '202CB962AC59075B964B07152D234B70' let s.max = 5 do crack md5;");
    ValidateNoError();
}

TEST_F(HLINQTest, CrackStrHashMinSet) {
    Run("for string s from hash '202CB962AC59075B964B07152D234B70' let s.min = 3 do crack md5;");
    ValidateNoError();
}

TEST_F(HLINQTest, CrackStrHashDictSet) {
    Run("for string s from hash '202CB962AC59075B964B07152D234B70' let s.dict = '0-9' do crack md5;");
    ValidateNoError();
}

TEST_F(HLINQTest, CrackStrHashAllSet) {
    Run("for string s from hash '202CB962AC59075B964B07152D234B70' let s.max = 5, s.dict = '0-9', s.min = 3 do crack md5;");
    ValidateNoError();
}

TEST_F(HLINQTest, CalcStrHashCrackBadRun) {
    Run("for string s from hash '83DCEFB7' do crack crc321;", FALSE);
    ValidateError();
}

TEST_F(HLINQTest, InvalidStrSyntaxRun) {
    Run("for string s from hash '83DCEFB7' do crack crc321;", FALSE);
    ValidateError();
}

TEST_F(HLINQTest, TwoDifferentQueries) {
    Run("for file f from dir 'z:' let f.limit = 1024, f.offset = 10 where f.name ~ '*.exe' do md5;for string '123' do sha1;");
    ValidateNoError();
}

TEST_F(HLINQTest, TwoQueries) {
    Run("for string '123' do sha1;for string '123' do md5;");
    ValidateNoError();
}

TEST_F(HLINQTest, CrackStr) {
    Run("for string s from hash 'D41D8CD98F00B204E9800998ECF8427E' let s.min = 4 do crack md5;");
    ValidateNoError();
}

TEST_F(HLINQTest, NoQueryEnd) {
    Run("for file f from dir 'c:' do md5");
    ValidateError();
}

TEST_F(HLINQTest, InvalidId) {
    Run("for file f from dir 'c:' where f1.size == 0 do find;");
    ValidateError();
}

TEST_F(HLINQTest, InvalidIdInLet) {
    Run("for string s from hash 'D41D8CD98F00B204E9800998ECF8427E' let s1.min = 4 do crack md5;");
    ValidateError();
}

TEST_F(HLINQTest, WhereSimple) {
    Run("for file f from dir 'c:' where f.size == 0 do find;");
    ValidateNoError();
}

TEST_F(HLINQTest, WhereTwoAnd) {
    Run("for file f from dir 'c:' where f.size == 0 and f.name ~ '*.exe' do find;");
    ValidateNoError();
}

TEST_F(HLINQTest, WhereTwoOr) {
    Run("for file f from dir 'c:' where f.size == 0 or f.name ~ '*.exe' do find;");
    ValidateNoError();
}

TEST_F(HLINQTest, WhereBraces) {
    Run("for file f from dir 'c:' where f.size == 0 and (f.name ~ '*.exe' or f.path ~ 'c:\\temp\\*') do find;");
    ValidateNoError();
}

TEST_F(HLINQTest, WhereBracesUnclosed) {
    Run("for file f from dir 'c:' where f.size == 0 and (f.name ~ '*.exe' or f.path ~ 'c:\\temp\\*' do find;");
    ValidateError();
}

TEST_F(HLINQTest, FileQuery) {
    Run("for file f from '1' do md5;");
    ValidateNoError();
}

TEST_F(HLINQTest, FileQueryWithLet) {
    Run("for file f from '1' let f.limit = 10 do md5;");
    ValidateNoError();
}

TEST_F(HLINQTest, FileQueryValidate) {
    Run("for file f from '1' let f.md5 = 'D41D8CD98F00B204E9800998ECF8427E' do validate;");
    ValidateNoError();
}

TEST_F(HLINQTest, FileQueryValidateNoLetClause) {
    Run("for file f from '1' do validate;");
    ValidateError();
}

TEST_F(HLINQTest, DirQueryFind) {
    Run("for file f from dir 'c:' where f.md5 == 'D41D8CD98F00B204E9800998ECF8427E' do find;");
    ValidateNoError();
}

TEST_F(HLINQTest, DirQueryFindNoWhereClause) {
    Run("for file f from dir 'c:' do find;");
    ValidateError();
}

TEST_F(HLINQTest, DirQueryFindLimitAndOffsetSet) {
    Run("for file f from dir '.' where f.md5 == 'D41D8CD98F00B204E9800998ECF84271' and f.limit == 100 and f.offset == 10 do find;", FALSE);
    ValidateNoError();
}

TEST_F(HLINQTest, DirQueryFindWithSize) {
    Run("for file f from dir '.' where f.size < 0 and f.md5 == 'D41D8CD98F00B204E9800998ECF84271' do find;", FALSE);
    ValidateNoError();
}

TEST_F(HLINQTest, DirQueryFindLimitOrClauseSet) {
    Run("for file f from dir '.' where f.md5 == 'D41D8CD98F00B204E9800998ECF84271' or f.limit == 10000 do find;", FALSE);
    ValidateError();
}

TEST_F(HLINQTest, DirQueryFindLimitAndOffsetOrClauseSet) {
    Run("for file f from dir '.' where f.md5 == 'D41D8CD98F00B204E9800998ECF84271' or f.limit == 10000 and f.offset == 10 do find;", FALSE);
    ValidateError();
}

TEST_F(HLINQTest, BigQueryFile) {
    ofstream f;
    f.open (TEST_QUERY_FILE, ios::out | ios::app);

    for(int i = 0; i < 10000; ++i) {
        f << "for file f from dir 'c:' where f.size == 0 and (f.name ~ '*.exe' or f.path ~ 'c:\\temp\\*') do find;" << endl;
    }
    f.close();
    RunFile(TEST_QUERY_FILE);
    ValidateNoError();
}

TEST_F(HLINQTest, VarDef) {
    Run("set x = 'c:';");
    ValidateNoError();
}

TEST_F(HLINQTest, VarLink) {
    Run("set x = 'c:';for file f from x do md5;");
    ValidateNoError();
}

TEST_F(HLINQTest, VarUnknownLink) {
    Run("set x = 'c:';for file f from y do md5;");
    ValidateError();
}

TEST_F(HLINQTest, VarLinkToSeveralStatementsRun) {
    Run("set x = '123';for string x do md5;for string x do sha1;", FALSE);
    ASSERT_STREQ("202CB962AC59075B964B07152D234B70\n40BD001563085FC35165329EA1FF5C5ECBDBBEEF\n", oss_.str().c_str());
}

TEST_F(HLINQTest, VarLinkInExpression) {
    Run("set x = 'D41D8CD98F00B204E9800998ECF8427E';for file f from '1' let f.md5 = x do validate;");
    ValidateNoError();
}

TEST_F(HLINQTest, VarUnknownLinkInExpression) {
    Run("set x = 'D41D8CD98F00B204E9800998ECF8427E';for file f from '1' let f.md5 = z do validate;", FALSE);
    ValidateError();
}

TEST_F(HLINQTest, VarLinkInExpressionRun) {
    Run("set x = 'D41D8CD98F00B204E9800998ECF84271';for file f from dir '.' where f.size < 0 and f.md5 == x do find;", FALSE);
    ValidateNoError();
}

TEST_F(HLINQTest, VarUnknownLinkInExpressionRun) {
    Run("set x = 'D41D8CD98F00B204E9800998ECF84271';for file f from dir '.' where f.size < 0 and f.md5 == g do find;", FALSE);
    ValidateError();
}