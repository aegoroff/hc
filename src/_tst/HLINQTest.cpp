/*!
 * \brief   The file contains class implementation
 * \author  \verbatim
            Created by: Alexander Egorov
            \endverbatim
 * \date    \verbatim
            Creation date: 2011-11-18
            \endverbatim
 * Copyright: (c) Alexander Egorov 2011
 */

#include "HLINQTest.h"
using namespace std;

void HLINQTest::SetUp()
{
    wcout_stream_buffer_ = wcout.rdbuf(woss_.rdbuf());
    wcerr_stream_buffer_ = wcerr.rdbuf(wosse_.rdbuf());
    cout_stream_buffer_ = cout.rdbuf(oss_.rdbuf());
    cerr_stream_buffer_ = cerr.rdbuf(osse_.rdbuf());
    apr_pool_create(&pool_, NULL);
}

void HLINQTest::TearDown()
{
    wcout.rdbuf(wcout_stream_buffer_);
    wcerr.rdbuf(wcerr_stream_buffer_);
    cout.rdbuf(cout_stream_buffer_);
    cerr.rdbuf(cerr_stream_buffer_);

    psr_->free(psr_);
    psr_ = NULL;
    tstream_->free(tstream_);
    tstream_ = NULL;
    lxr_->free(lxr_);
    lxr_ = NULL;
    input_->close(input_);
    input_ = NULL;
    
    apr_pool_destroy(pool_);
}

void HLINQTest::Run(const char* q)
{
    const char* utf8 = FromAnsiToUtf8(q, pool_);
    input_   = antlr3StringStreamNew((pANTLR3_UINT8)utf8, ANTLR3_ENC_UTF8, strlen(q), (pANTLR3_UINT8)"");
    lxr_     = HLINQLexerNew(input_);     // HLINQLexerNew is generated by ANTLR
    tstream_ = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr_));
    psr_     = HLINQParserNew(tstream_);  // HLINQParserNew is generated by ANTLR3
    psr_->prog(psr_, pool_, TRUE);
}

void HLINQTest::ValidateNoError()
{
    ASSERT_STREQ(L"", woss_.str().c_str());
    ASSERT_STREQ(L"", wosse_.str().c_str());
    ASSERT_STREQ("", oss_.str().c_str());
    ASSERT_STREQ("", osse_.str().c_str());
}

TEST_F(HLINQTest, DelFile) {
    Run("for f in 'c:\\' do delete;");
    ValidateNoError();
}

TEST_F(HLINQTest, PrnFileName) {
    Run("for f in 'c:\\' do print f.name;");
    ValidateNoError();
}

TEST_F(HLINQTest, DelFileNameEq) {
    Run("for f in 'c:\\' where f.name = 'test' do delete;");
    ValidateNoError();
}

TEST_F(HLINQTest, CalcStrHash) {
    Run("for '123' do sha1;");
    ValidateNoError();
}

TEST_F(HLINQTest, CrackStr) {
    Run("for 'D41D8CD98F00B204E9800998ECF8427E' as s let s.min = 4 do crack md5;");
    ValidateNoError();
}